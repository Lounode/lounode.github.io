{"meta":{"title":"Lounode's Blog","subtitle":"OIer/蒟蒻/车万众","description":"好想做个女孩子XD","author":"Lounode","url":"http://blog.lounode.com","root":"/"},"pages":[],"posts":[{"title":"「数据结构」线段树","slug":"segmenttree","date":"2019-11-10T14:56:16.000Z","updated":"2019-11-11T09:07:22.339Z","comments":true,"path":"2019/11/10/segmenttree/","link":"","permalink":"http://blog.lounode.com/2019/11/10/segmenttree/","excerpt":"","text":"假设有这么一些问题： 这些问题都可以抽象成若干个区间操作，那么问题来了，如何处理这些操作呢？ 首先我们考虑一下朴素做法，每次操作时，用 \\text{for} 循环每次从操作区间的左端点循环到右端点，在这个过程中维护一些信息，查询同理。 但很快我们就发现，这种方法实在是过于低效了，假如每次操作都是从区间的开头循环到结尾，那么这样的时间复杂度就是 O(n^2) 的，对于一些查询次数在 10^5 以内的操作就会 \\text{TLE} 。 应该如何去优化算法，使它能处理一些区间的问题呢？ 先来想想朴素的做法为何很慢？因为它对于每个操作，都去进行了一遍更新，考虑之前接触过的记忆化搜索、递推等，我们想到：是否能在一次操作中用一些方式 存下 这些信息，然后用到的时候再朴素的求呢？ 答案是可行的，想想我们之前学过的前缀和与差分，其核心思想就是这样。 比如现在让你求这个序列某一段区间的和，我们可以考虑对这个序列做一个前缀和。 但是这样做的话是不支持修改的，如果需要修改的话每次都要重新对序列求一个前缀和，它又退化到了 O(n^2) 查询次数一多还是会 \\text{TLE} 。 那么还能如何优化呢？ 不如分析下这些问题，我们发现，这些问题都是对区间的一系列操作。废话？不不不，这正是接下来的重点，既然都是维护区间的操作的话，我们能不能在记录信息的时候记录的是 区间 的信息呢？ 显然是可以的，那么如何实现呢？ 对了，结构体！我们可以用一个结构体来保存一个区间的信息。 12345struct Area &#123; int l; //区间左端点 (Left) int r; //区间右端点 (Right) int dat;//区间的信息 (Data)&#125;; 有了这个后，我们接着来想下一步怎么做。如何简化修改与查询呢？对，分治，可以吧这个大区间分成若干个小区间，对于大区间的操作直接进行，对于小区间的操作再逐个完成。 在这里，我们正式引入 线段树 这个数据结构。 何为线段树？线段树即为一种维护区间满足 结合律 的信息的数据结构。 结合律：在一个包含有二个以上的可结合运算符的式子中，只要运算符的位置没有改变，运算的顺序就不会对运算出来的结果有影响。重新排列式子中的括号不会改变表达式的值。 比如： a+b+c=a+(b+c) ， a \\times b \\times c=a \\times (b \\times c) 考虑将一个区间 \\text{[1,n]} 分割成如下图 logn 个子区间，我们发现这些子区间正好组成了一棵完全二叉树。 那么，对区间 [3,7] 的操作就可以转化为：对子区间 [3,4],[5,6],[7,7] 的操作。 由于树高最多为 logn 层，那么每次操作的时间复杂度就是 O(logn) 的。","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://blog.lounode.com/tags/线段树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://blog.lounode.com/tags/数据结构/"}]},{"title":"「题解」 Luogu P5613 [MtOI2019]黑蚊子多","slug":"luogup5613","date":"2019-11-10T11:52:25.000Z","updated":"2019-11-10T15:30:22.793Z","comments":true,"path":"2019/11/10/luogup5613/","link":"","permalink":"http://blog.lounode.com/2019/11/10/luogup5613/","excerpt":"","text":"真人面对面收割，美女角色在线掉分，发狂玩蛇新天地。 ---Arcaea中文维基 以下是正文 可以考虑这么一张图： 每次向上走 m 格，在其中有 k 个特殊平台，踩上去后后面每次向上走 m+1 格。 对于 60% 的数据，k = 0。 那么要从底部到达顶部所需要的最小次数就是 \\frac{n}{m} 次，只需要输出 \\frac{n}{m} 即可得到此部分的分数。 对于 100% 的数据，1 ≤ m ≤ n ≤ 1000 ，k ≤ 10 。 1≤ n ≤ 1000 所以我们可以开一个数组存储哪些是特殊平台 ，然后模拟就好了。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main () &#123; int n,m,k; int a[1010]; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= k; i++) &#123; int in; cin&gt;&gt;in; a[in]=1;//存储特殊格子 &#125; int ans=0; int t=0;//当前位置 while (true) &#123; if(n-m&lt;=0) &#123;//边界 ans++;//即使剩余格子小于m 也还是需要走一次的 break; &#125; n-=m;//剩余格子 t+=m;//当前位置 m+=a[t];//如果特殊为格子 m+=1 ans++; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://blog.lounode.com/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"http://blog.lounode.com/tags/模拟/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-03T16:00:00.000Z","updated":"2019-11-10T15:11:49.849Z","comments":true,"path":"2019/10/04/hello-world/","link":"","permalink":"http://blog.lounode.com/2019/10/04/hello-world/","excerpt":"","text":"第一篇博客吧.QwQ 测试Markdown语法. 顺便放点更新日志： 19.10.4 Blog初步搭建完成，添加了看板娘。 19.10.5 添加了评论系统。 19.11.10 换了主题、Markdown渲染插件。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://blog.lounode.com/categories/杂项/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://blog.lounode.com/tags/misc/"}]}]}
{"meta":{"title":"Lounode's Blog","subtitle":null,"description":null,"author":"Lounode","url":"http://blog.lounode.com","root":"/"},"pages":[],"posts":[{"title":"「题解」 Luogu P5613 [MtOI2019]黑蚊子多","slug":"luogup5613","date":"2019-11-10T11:52:25.000Z","updated":"2019-11-10T12:02:50.557Z","comments":true,"path":"2019/11/10/luogup5613/","link":"","permalink":"http://blog.lounode.com/2019/11/10/luogup5613/","excerpt":"","text":"真人面对面收割，美女角色在线掉分，发狂玩蛇新天地。 ---Arcaea中文维基 以下是正文 可以考虑这么一张图 每次向上走 m 格，在其中有 k 个特殊平台，踩上去后后面每次向上走 m+1 格。 对于 60% 的数据，k = 0。 那么要从底部到达顶部所需要的最小次数就是 \\frac{n}{m} 次，只需要输出 \\frac{n}{m} 即可得到此部分的分数。 对于 100% 的数据，1 ≤ m ≤ n ≤ 1000 ，k ≤ 10 。 1≤ n ≤ 1000 所以我们可以开一个数组存储哪些是特殊平台 。然后模拟就好了 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main () &#123; int n,m,k; int a[1010]; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= k; i++) &#123; int in; cin&gt;&gt;in; a[in]=1;//存储特殊格子 &#125; int ans=0; int t=0;//当前位置 while (true) &#123; if(n-m&lt;=0) &#123;//边界 ans++;//即使剩余格子小于m 也还是需要走一次的 break; &#125; n-=m;//剩余格子 t+=m;//当前位置 m+=a[t];//如果特殊为格子 m+=1 ans++; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-03T16:00:00.000Z","updated":"2019-11-10T11:45:26.997Z","comments":true,"path":"2019/10/04/hello-world/","link":"","permalink":"http://blog.lounode.com/2019/10/04/hello-world/","excerpt":"","text":"第一篇博客吧.QwQ 测试Markdown语法. 顺便放点更新日志： 19.10.4 Blog初步搭建完成，添加了看板娘。 19.10.5 添加了评论系统。 19.11.10 换了主题、Markdown渲染插件。","categories":[{"name":"misc","slug":"misc","permalink":"http://blog.lounode.com/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://blog.lounode.com/tags/misc/"}]}]}